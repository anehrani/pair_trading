"""Core strategy logic extracted from backtest for live use.

Implements pair selection, copula fitting, and signal generation.
"""

from __future__ import annotations

from dataclasses import dataclass

import numpy as np
import pandas as pd
from loguru import logger
from scipy import stats

from src.copula_model import fit_best_marginal, fit_copula_candidates, h_functions_numerical
from src.stats_tests import cointegration_with_reference


@dataclass
class TradingPair:
    """Selected pair for trading."""

    symbol1: str
    symbol2: str
    beta1: float
    beta2: float
    tau1: float  # Kendall tau with reference
    tau2: float


@dataclass
class CopulaModel:
    """Fitted copula model for a pair."""

    marginal1: object  # FittedMarginal
    marginal2: object  # FittedMarginal
    copula: object  # FittedCopula
    beta1: float
    beta2: float


@dataclass
class TradingSignal:
    """Trading signal generated by strategy."""

    action: str  # "LONG_S1_SHORT_S2", "SHORT_S1_LONG_S2", "CLOSE", "WAIT"
    h1_2: float  # Conditional probability h_{1|2}
    h2_1: float  # Conditional probability h_{2|1}
    timestamp: pd.Timestamp


def kendall_tau(x: pd.Series, y: pd.Series) -> float:
    """Calculate Kendall's tau correlation coefficient."""
    a, b = x.align(y, join="inner")
    a = a.to_numpy(dtype=float)
    b = b.to_numpy(dtype=float)
    mask = np.isfinite(a) & np.isfinite(b)
    if mask.sum() < 100:
        return float("nan")
    tau, _p = stats.kendalltau(a[mask], b[mask])
    return float(tau) if tau is not None else float("nan")


def select_trading_pair(
    prices: pd.DataFrame,
    reference_symbol: str,
    eg_alpha: float = 1.00,
    adf_alpha: float = 0.10,
    kss_critical: float = -1.92,
) -> tuple[TradingPair | None, pd.DataFrame]:
    """Select top 2 altcoins cointegrated with reference asset.

    Args:
        prices: DataFrame with timestamp index and symbol columns
        reference_symbol: Reference asset (e.g., "BTCUSDT" for crypto or "SPY" for stocks)
        eg_alpha: Engle-Granger p-value threshold
        adf_alpha: ADF p-value threshold
        kss_critical: KSS critical value

    Returns:
        (TradingPair or None, DataFrame of all results)
    """
    if reference_symbol not in prices.columns:
        logger.error(f"Reference symbol {reference_symbol} not in prices")
        return None, pd.DataFrame()

    ref = prices[reference_symbol].dropna()
    candidates = [c for c in prices.columns if c != reference_symbol]

    stats_rows: list[dict] = []

    for sym in candidates:
        # Test cointegration
        res = cointegration_with_reference(
            ref,
            prices[sym],
            eg_alpha=eg_alpha,
            adf_alpha=adf_alpha,
            kss_critical_10pct=kss_critical,
            use_intercept=False,
        )

        if res is None:
            continue

        # Calculate Kendall tau
        tau = kendall_tau(ref, prices[sym])
        if not np.isfinite(tau):
            continue

        # Calculate score: abs(kss)/10 + (eg + adf)/2
        score = abs(res.kss_stat) / 10.0 + (res.eg_pvalue + res.adf_pvalue) / 2.0

        stats_rows.append({
            "reference": reference_symbol,
            "asset": sym,
            "beta": res.beta,
            "eg_pvalue": res.eg_pvalue,
            "adf_pvalue": res.adf_pvalue,
            "kss_stat": res.kss_stat,
            "observations": len(res.spread),
            "score": score,
            "tau": tau,  # Still need tau for sorting
        })

    if not stats_rows:
        logger.warning("No cointegrated pairs found")
        return None, pd.DataFrame()

    results_df = pd.DataFrame(stats_rows)

    if len(stats_rows) < 2:
        logger.warning(f"Only {len(stats_rows)} cointegrated pairs found, need at least 2")
        return None, results_df.drop(columns=["tau"])

    # Sort by tau (descending) and pick top 2
    results_df = results_df.sort_values("tau", ascending=False)
    
    s1 = results_df.iloc[0]["asset"]
    tau1 = results_df.iloc[0]["tau"]
    beta1 = results_df.iloc[0]["beta"]
    
    s2 = results_df.iloc[1]["asset"]
    tau2 = results_df.iloc[1]["tau"]
    beta2 = results_df.iloc[1]["beta"]

    logger.info(f"Selected pair: {s1} (τ={tau1:.3f}, β={beta1:.3f}), {s2} (τ={tau2:.3f}, β={beta2:.3f})")

    pair = TradingPair(
        symbol1=str(s1),
        symbol2=str(s2),
        beta1=float(beta1),
        beta2=float(beta2),
        tau1=float(tau1),
        tau2=float(tau2),
    )
    
    # Drop tau before returning for reporting
    report_df = results_df.drop(columns=["tau"]).sort_values("score", ascending=True)
    
    return pair, report_df


def fit_copula_model(
    prices: pd.DataFrame,
    pair: TradingPair,
    reference_symbol: str,
) -> CopulaModel | None:
    """Fit copula model to spread processes.

    Args:
        prices: Formation period prices
        pair: Selected trading pair
        reference_symbol: Reference asset

    Returns:
        CopulaModel if successful, None otherwise
    """
    try:
        ref = prices[reference_symbol]
        p1 = prices[pair.symbol1]
        p2 = prices[pair.symbol2]

        # Calculate spreads: S_i = P_ref - beta_i * P_i
        s1 = ref - pair.beta1 * p1
        s2 = ref - pair.beta2 * p2

        # Fit marginal distributions
        m1 = fit_best_marginal(s1.to_numpy(dtype=float))
        m2 = fit_best_marginal(s2.to_numpy(dtype=float))

        # Transform to uniform via PIT
        u1 = m1.cdf(s1.to_numpy(dtype=float))
        u2 = m2.cdf(s2.to_numpy(dtype=float))
        u = np.column_stack([u1, u2])
        u = u[np.isfinite(u).all(axis=1)]

        if u.shape[0] < 50:
            raise ValueError("Not enough valid PIT samples")

        # Fit copula
        fitted = fit_copula_candidates(u)

        # Find best copula that supports CDF
        best = None
        for cand in fitted:
            try:
                _ = cand.copula.cdf(np.array([[0.5, 0.5]], dtype=float))
                best = cand
                break
            except (NotImplementedError, Exception):
                continue

        if best is None:
            raise ValueError("No copula supports CDF evaluation")

        logger.info(f"Fitted copula: {best.name} (AIC={best.aic:.2f})")

        return CopulaModel(
            marginal1=m1,
            marginal2=m2,
            copula=best,
            beta1=pair.beta1,
            beta2=pair.beta2,
        )

    except Exception as e:
        logger.error(f"Failed to fit copula model: {e}")
        return None


def generate_signal(
    current_prices: dict[str, float],
    model: CopulaModel,
    pair: TradingPair,
    reference_symbol: str,
    alpha1: float,
    alpha2: float,
) -> TradingSignal:
    """Generate trading signal from current prices.

    Args:
        current_prices: Dict mapping symbol to current price
        model: Fitted copula model
        pair: Trading pair
        reference_symbol: Reference asset
        alpha1: Entry threshold
        alpha2: Exit threshold

    Returns:
        TradingSignal
    """
    # Get current prices
    p_ref = current_prices[reference_symbol]
    p1 = current_prices[pair.symbol1]
    p2 = current_prices[pair.symbol2]

    # Calculate current spreads
    s1_t = p_ref - model.beta1 * p1
    s2_t = p_ref - model.beta2 * p2

    # Transform to uniform
    u1_t = float(model.marginal1.cdf(s1_t))
    u2_t = float(model.marginal2.cdf(s2_t))

    # Calculate h-functions
    h1_2, h2_1 = h_functions_numerical(model.copula.copula, u1_t, u2_t)

    # Trading rules (Table 3 & 4 from paper)
    action = "WAIT"

    if h1_2 < alpha1 and h2_1 > (1 - alpha1):
        action = "LONG_S1_SHORT_S2"  # Long beta2*P2, Short beta1*P1
    elif h1_2 > (1 - alpha1) and h2_1 < alpha1:
        action = "SHORT_S1_LONG_S2"  # Short beta2*P2, Long beta1*P1
    elif abs(h1_2 - 0.5) < alpha2 and abs(h2_1 - 0.5) < alpha2:
        action = "CLOSE"

    return TradingSignal(
        action=action,
        h1_2=h1_2,
        h2_1=h2_1,
        timestamp=pd.Timestamp.now(tz="UTC"),
    )


def calculate_position_sizes(
    beta1: float,
    beta2: float,
    p1: float,
    p2: float,
    capital_per_side: float,
) -> tuple[float, float]:
    """Calculate position sizes for each asset.

    Args:
        beta1: Beta for asset 1
        beta2: Beta for asset 2
        p1: Price of asset 1
        p2: Price of asset 2
        capital_per_side: Maximum capital per leg

    Returns:
        (qty1, qty2) quantities
    """
    denom = max(abs(beta1 * p1), abs(beta2 * p2))
    if denom <= 0:
        return 0.0, 0.0

    k = capital_per_side / denom
    q1 = k * beta1
    q2 = k * beta2

    return float(q1), float(q2)
